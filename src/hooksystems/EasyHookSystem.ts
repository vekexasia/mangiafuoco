import { IFilterModel, IHandlerRegistration } from '../filtermodel';
import { Handler } from '../handler';
import { BaseHookSystem } from './BaseHookSystem';

export class EasyHookSystem {
  public constructor(private model: IFilterModel) {
  }

  // tslint:disable-next-line max-line-length
  public async register<T>(eventName: string, handler: Handler<T, any>, priority: number = 10): Promise<IHandlerRegistration> {
    return this.getFilter(eventName)
      .addHandler({handler, priority});
  }

  /**
   * emits the event to all handlers parallelly and returns the results generated by each one of them
   * Note that result array is ordered as handlers priority.
   * @param eventName the event Name Ex: user_purchase
   * @param [payload=null] the payload that might be used by handlers. Ex: { amount: 100 }
   * @returns {Promise<T[]>}
   */
  public async do<T>(eventName: string, payload: T = null) {
    return this.getFilter(eventName)
      .parallel(payload);
  }

  /**
   * sequentially send event out to handlers and returns last handler result
   * @param eventName the event Name Ex: validate_email
   * @param [payload=null] the payload sent to first handler: Ex: 'me@andreabaccega.com'
   * @returns {Promise<T>|Promise<R>}
   */
  public async map<T>(eventName: string, payload?: T): Promise<T>;
  public async map<T, R extends T>(eventName: string, payload?: T): Promise<R>;
  public async map<T>(eventName: string, payload: T = null) {
    return this.getFilter(eventName)
      .series(payload);
  }
  /**
   * emits the event to all handlers parallelly but does not wait for the handlers
   * to complete their execution.
   * @param eventName
   * @param payload
   * @returns {boolean}
   */
  public enqueueDo<T>(eventName: string, payload: T = null): true {
    setImmediate(async () => {
      await this.do(eventName, payload);
    });
    return true;
  }

  private getFilter<T>(eventName: string) {
    return new BaseHookSystem<T>(eventName, this.model);
  }

}
