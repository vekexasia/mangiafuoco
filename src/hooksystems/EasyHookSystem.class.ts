import { FilterModel, HandlerRegistration } from '../filtermodel/filter.model.interface';
import { BaseHookSystem } from './BaseHookSystem.class';
import { Handler } from '../handler/base.class';
export class EasyHookSystem {
  constructor(private model: FilterModel) {
  }

  private getFilter<T>(eventName: string) {
    return new BaseHookSystem<T>(eventName, this.model);
  }

  async register<T>(eventName: string, handler: Handler<T, any>, priority: number = 10): Promise<HandlerRegistration> {
    return this.getFilter(eventName)
      .addHandler({handler, priority});
  }

  /**
   * emits the event to all handlers parallelly and returns the results generated by each one of them
   * Note that result array is ordered as handlers priority.
   * @param eventName the event Name Ex: user_purchase
   * @param [payload=null] the payload that might be used by handlers. Ex: { amount: 100 }
   * @returns {Promise<T[]>}
   */
  async do<T>(eventName: string, payload: T = null) {
    return this.getFilter(eventName)
      .processParallel(payload);
  }

  /**
   * sequentially send event out to handlers and returns last handler result
   * @param eventName the event Name Ex: validate_email
   * @param [payload=null] the payload sent to first handler: Ex: 'me@andreabaccega.com'
   * @returns {Promise<T>|Promise<R>}
   */
  async map<T>(eventName: string, payload?: T): Promise<T>;
  async map<T, R extends T>(eventName: string, payload?: T): Promise<R>;
  async map<T>(eventName: string, payload: T = null) {
    return this.getFilter(eventName)
      .process(payload);
  }

  /**
   * emits the event to all handlers parallelly but does not wait for the handlers
   * to complete their execution.
   * @param eventName
   * @param payload
   * @returns {boolean}
   */
  enqueueDo<T>(eventName: string, payload: T = null): true {
    setImmediate(async() => {
      await this.do(eventName, payload);
    });
    return true;
  }

}